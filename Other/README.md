## 什么是Ajax请求？

`ajax`是一个异步请求，它允许在不刷新整个页面的情况下，通过异步方式与服务器进行数据交换和更新一部分页面内容.

### Ajax怎么实现的

通过利用`JavaScript`和`XMLHttpRequest`对象发布异步请求实现，
并且通过回调函数处理服务器返回的数据，而且可以直接在后台发送请求和接收响应的同时继续与页面交互

​			（死滚）
使用JavaScript来更新页面

它还可以与多种数据格式（如`JSON`、`HTML`等）进行交互

## 什么是异步？

异步（Asynchronous）是一种编程模型，在异步编程中，可以同时执行多个操作，而不需要等待前一个操作是否完成，他就会进行另一个操作。               （抛咩死）

在JavaScript中，异步编程常见的方式包括使用回调函数、Promise对象、async/await语法和事件监听器等

## 什么是`spring`框架？

Spring框架是开发的设计层面框架，可以解决业务的逻辑层和其他层的松耦合问题，可以让我们能够更加高效地开发

### spring框架的优点

方便解耦，简化开发，AOP编程支持，声明事务支持。还可以更加方便的分层测试。

### 事务

事务可以确保数据库操作要么全部成功提交，要么全部失败回滚。

可以使用编程式事务，声明式事务，容器管理事务

编程式事务则需要开发人员手写事务控制代码



```java
//获取数据库连接：通过数据源获取数据库连接对象。
//设置事务属性：调用setAutoCommit(false)方法将自动提交设置为false，以手动管理事务。
//执行数据库操作：在事务内执行所需的数据库操作。
//提交事务：如果所有操作成功，调用commit()方法提交事务。
//回滚事务：如果操作失败，通过捕获异常并调用rollback()方法回滚事务。
释放资源：在finally块中，确保关闭数据库连接。
Connection connection = null;
try {
    connection = dataSource.getConnection();
    connection.setAutoCommit(false); // 开始事务
// 执行数据库操作
// ...

	connection.commit(); // 提交事务
    } catch (SQLException e) {
    connection.rollback(); // 回滚事务
} finally {
    if (connection != null) {
        connection.close();
    }
}
```


声明式事务可以直接使用注解由框架来管理事务的提交回滚。

```java
//可以使用Spring框架中的DataSourceTransactionManager作为事务管理器。
//可以在Spring框架中的配置文件中创建一个事务管理器的bean，
//启用事务支持：确保在配置文件中启用了事务支持。对于Spring框架，可以使用<tx:annotation-driven>标签或@EnableTransactionManagement注解来启用事务支持。
@Transactional
public void performDatabaseOperation() {
    // 执行数据库操作
    // ...
}
```

容器管理事务可以依赖应用服务器（如`Java EE`容器）提供的事务管理功能

```java
@Resource
private UserTransaction userTransaction;

public void performDatabaseOperation() {
    try {
        userTransaction.begin(); // 开始事务

        // 执行数据库操作
        // ...

        userTransaction.commit(); // 提交事务
    } catch (Exception e) {
        userTransaction.rollback(); // 回滚事务
    }
}

```



## `springMVC`是什么？

`Spring MVC`是`Spring`框架中的一个模块，用于开发基于Java的Web应用程序

## 什么是 `MyBatis`

`MyBatis` 是一个可以自定义 `SQL`、存储过程和高级映射的持久层框架。

### `MyBatis `动态 `SQL `是做什么的？都有哪些动态 `SQL`？能简述一下动态 `SQL` 的执行原理不？

`MyBatis`动态`SQL`是一种可以在`SQ`L语句中根据不同条件生成不同`SQL`片段的特性。

`MyBatis`提供了几种常见的动态`SQL`语句：

1. if语句：可以根据条件判断是否包含某个`SQL`片段。
2. choose语句：类似于Java中的switch语句，根据条件选择执行某个`SQL`片段。
3. where语句：用于构建WHERE子句，根据条件动态添加查询条件。
4. set语句：用于构建UPDATE语句的SET子句，根据条件动态设置更新字段。
5. `foreach`(佛已吃)语句：用于循环遍历集合或数组，生成重复的SQL片段。

执行原理：

`MyBatis`首先解析`SQL`语句，识别其中的动态`SQL`部分，根据动态`SQL`的条件判断，动态生成最终的`SQL`语句，最后在数据库中执行

​									（哭k）

## Session 和 Cookie 有什么区别？

存储位置不同：`Session` 存储在服务器端；`Cookie` 存储在浏览器端。
安全性不同：`Cookie` 安全性一般，在浏览器存储，可以被伪造和修改。
容量和个数限制：`Cookie` 有容量限制，每个站点下的 `Cookie` 也有个数限制。
存储的多样性：`Session` 可以存储在 `Redis` 中、数据库中、应用程序中；而 `Cookie` 只能存储在浏览器中。

Session也有一些潜在的问题。由于Session数据存储在服务器端，它需要占用服务器的内存资源。
当同时有大量用户访问时，会增加服务器的负载

## `springMVC`的工作原理？   

​												（地死拍车）
首先向客户端发送HTTP请求到DispatcherServlet 			          
然后通过`handlerMapping`(韩弄来卖配)查询到对应的`Controller`(肯凑乐)，然后直接返回对应的`ModelAndView ` （Vu）`DispatcherServlet` 查询` ModelAndView`，找到指定视图、视图将结果返回到客户端。

## Spring MVC 流程？

1. 用户发送请求至前端控制器 `DispatcherServlet`。
2. `DispatcherServlet` 收到请求调用` HandlerMapping` 处理器映射器。
3. 处理器映射器找到具体的处理器 (可以根据 XML 配置、注解进行查找)，生成处理器对象及处理器拦截器 (如果有则生成) 一并返回给 `DispatcherServlet`。
4. `DispatcherServlet` 调用` HandlerAdapter`（饿呆特） 处理器适配器。
5. `HandlerAdapter` 经过适配调用具体的处理器 (`Controller`，也叫后端控制器)。
6. `Controller` 执行完成返回` ModelAndView`。
7. `HandlerAdapter `将 `controller` 执行结果 `ModelAndView` 返回给 `DispatcherServlet`。`DispatcherServlet `将` ModelAndView `传给 `ViewReslover`(爷我死楼我) 视图解析器。
8. `ViewReslover` 解析后返回具体 `View`。
9. `DispatcherServlet `根据 `View `进行渲染视图（即将模型数据填充至视图中）。
10. `DispatcherServlet` 响应用户。

## 为什么`String`是不可变的

因为保存字符串的数组被final修饰，并且string没有提供/暴露修改这个字符串的方法

## js中的==和===有什么区别

当使用`==`运算符时，`javascript`会进行类型转换，并尝试将它们转换为相同的类型，然后再进行比较。

如果想要进行严格的类型和值比较，可以使用`===`运算符，因为它不会进行类型转换。

## Integer的比较

```java
 Integer a = 100;
    Integer b = 100;
    System.out.println(a==b);
//相等。true
Integer a = 200;
    Integer b = 200;
    System.out.println(a==b);
//不相等。false
```

为什么-128到127是相等

整数值在-128到127之间创建`Integer`对象时，如果该值已经在缓存范围内，Java会直接返回缓存中的对象，而不是创建新的对象。这意味着对于这个范围内的整数，相同的整数值会引用相同的对象。而当值超过这个范围时，会创建新的对象，所以`a==b`会返回`false`。

这个缓存机制只适用于自动装箱的情况，即使用整数值直接赋值给`Integer`对象。如果使用`new Integer()`显式创建`Integer`对象，那么不会使用缓存机制，每次都会创建新的对象。

## select的生命周期

`Servlet`是Java中用于处理Web请求和生成Web响应的组件。`Servlet`的生命周期是指`Servlet`从创建到销毁的整个过程，其中包括初始化、请求处理和销毁三个主要阶段。

## `IOC`  `DI`  `AOP`

` IOC`（控制反转）：`IOC`是一种设计原则，把对象的创建和依赖关系交给`IOC`容器来管理，不在由对象自身来创建和管理依赖关系。这种控制反转的机制可以减少对象之间的耦合。

`DI`（依赖注入）：`DI`是`IOC`的一种实现方式，他在 `IOC` 的基础上进行对象的属性注入。实现对象之间的解耦。

依赖注入包含了：构造函数注入、`Setter`方法注入或字段注入,接口注入等方式实现。

`Spring`容器会负责解析依赖关系并将相应的依赖注入到对象中。

`AOP`（面向切面编程）：`AOP`是一种编程范式。它可以在不修 改源码的基础上，还能对源码进行前后增强。

通过使用`@Aspect`(啊死白车)来进行标识该类为切面类。`@Before` (b佛儿) 注解定义了一个前置通知,`@After` (啊特)注解定义了一个后置通知

## Apache Shiro 的三大核心组件

1. `Subject` (杀不杰)：当前用户的操作。
2. `SecurityManager`(色Q里没力杰)：用于管理所有的 Subject。
3. `Realms`（瑞子）：用于进行权限信息的验证。

## `Shiro `可以完成哪些工作？

`Shiro` 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。

## 什么是`API`

它是一组定义了软件组件之间交互的规范和约定。

`API`的设计通常包括请求和响应的数据格式、访问权限、可用的功能等方面的定义。

## 数组（`Array`）和集合（`Collection`）

1.数组的长度不可变，集合的长度是动态的。

2.数组中存储的是一种类型的元素，可以存储任意类型数据。

3.集合存储的都是引用数据类型，如果想存储基本类型数据需要存储对应的包装类型

## 页面重定向？

​										 （楼k神）         							   		（瑞普类）
可以使用`javaScript`的`location`来进行页面重定向   `href`和`replace`

如何在 JavaScript 中每 x 秒调用一个函数？
		（色停的喔）
使用`setInterval`函数

```javascript
setInterval(function (){ alert("Hello"); }, 3000);
```

## 自动装箱与拆箱

1. 装箱：将基本类型转换为引用类型包装起来；
2. 拆箱：将包装类型转换为基本数据类型；

```java
int num = 10;
Integer obj = Integer.valueOf(num); // 装箱

Integer obj = Integer.valueOf(20);
int num = obj.intValue(); // 拆箱

```

## 如何在 JavaScript 中每 x 秒调用一个函数？

(色停特沃)

`setInterval(function (){ alert("Hello"); }, 3000);` // 每隔 3000 毫秒（即 3 秒），执行一次匿名函数 `function (){ alert("Hello");

## JavaScript 内置可用类型



基本数据类型 

```  
undefined：表示未定义的值。
null：表示空值。
boolean：表示布尔值，可以是true或false。
number：表示数字，可以是整数或浮点数。
string：表示字符串，用单引号或双引号括起来的字符序列。
symbol：表示唯一的、不可变的值，通常用作对象属性的键。

```

引用数据类型

``` 
Object：表示对象，是一种复合值，可以包含多个属性。
Array：表示数组，是一种特殊的对象，用于存储有序的元素集合。
Function：表示函数，是一种可执行的对象，可以被调用执行。
Date：表示日期和时间的对象。
RegExp：表示正则表达式的对象，用于模式匹配和替换。
Map：表示键值对的集合，其中键和值可以是任意类型。
Set：表示唯一值的集合，其中值可以是任意类型
```

## jQuery 中 .*g**e**t*()提交和.post () 提交有区别吗？

jQuery中的`$.get()`和`$.post()`是两种不同的AJAX请求方法，它们在提交数据和接收响应的方式上有一些区别。

1. `$.get()`方法：

   - 使用GET请求发送数据到服务器。

   - 将数据附加在URL的查询字符串中，以键值对的形式发送。

   - 可以通过URL参数传递数据，但对于较大的数据，不建议使用GET请求。

   - 示例：

     ```javascript
     $.get(url, data, successCallback, dataType);
     ```

2. `$.post()`方法：

   - 使用POST请求发送数据到服务器。

   - 将数据作为请求的正文发送，而不是附加在URL上。

   - 可以发送较大的数据，且更安全，因为数据不会显示在URL中。

   - 示例：

     ```javascript
     $.post(url, data, successCallback, dataType);
     ```

共同点：

- 都是`jQuery`提供的AJAX请求方法，用于向服务器发送异步请求。
- 都支持传递数据、指定成功回调函数和指定响应数据类型。

区别：

- 请求方式：`$.get()`使用GET请求，`$.post()`使用POST请求。
- 数据传递方式：`$.get()`将数据附加在URL的查询字符串中，`$.post()`将数据作为请求的正文。
- 数据大小限制：由于URL长度限制，`$.get()`对数据大小有限制，不适合发送较大的数据，而`$.post()`没有这个限制。
- 数据安全性：由于`$.get()`将数据显示在URL中，可能会导致数据泄露，而`$.post()`将数据作为请求的正文，更安全。

## 什么是`CDN`？

`CDN`是一种分布式的网络架构，可以提高内容传输和交付服务。

好处：能够加速网站内容传输、提升用户体验和降低服务器负载的重要技术。

##  `MySQL`的事故

`MySQL`数据库的运行过程中发生的意外事件或错误，导致数据库的功能受到影响或无法正常工作。

发生事故的原因：

数据库崩溃：可能是由于硬件故障、操作系统错误、内存问题、磁盘损坏等原因引起的。当数据库崩溃时，可能会导致数据丢失或无法访问数据库。

数据库性能问题：如慢查询、高负载、死锁等。这些问题可能导致数据库响应变慢，影响应用程序的性能和用户体验。

数据库备份和恢复问题：在进行数据库备份或恢复过程中，可能会发生错误或遇到挑战。如果备份不完整或恢复不正确，可能导致数据丢失或数据库不一致。

数据库安全问题：`MySQL`数据库可能面临安全问题，如未经授权的访问、数据泄露、注入攻击等。这些安全问题可能导致数据泄露、数据损坏或系统被黑客入侵。

解决：

故障排查和日志分析,通过使用备份文件进行恢复，或者使用`MySQL`的日志文件进行回滚和恢复操作。但恢复数据库时，需要确保数据的完整性和一致性。还可以进行一些性能优化安全加固等。

## `MySQL`的事务

`MySQL`的事务是一组数据库操作的集合，被视为一个单独的工作单元，要么全部成功执行，要么全部回滚。

好处：可以确保数据库操作的一致性和完整性，并提供并发控制和故障恢复的机制。

## `java`的基本数据类型

整数型：byte(1),short(2),int(4),long(8)

浮点型：float(4) double(8)

字符型：char（2）

布尔型：boolean（1字节）

## 面向对象

面向对象是一种编程范式，他最基本的数据单位是对象，而不是基本数据类型。

#### 封装：

将数据和对数据的操作封装在一个单元中，通过定义类来实现。只暴露必要的接口供其他对象进行访问。这样可以提高代码的可维护性和可复用性。

#### 继承：

继承是指一个类（称为子类或派生类）可以继承另一个类（称为父类或基类）的属性和方法。通过继承，子类可以获得父类的特性，并可以在此基础上进行扩展或修改。

#### 多态：

它允许使用统一的接口来处理不同类型的对象，具体来说，通过使用父类引用指向子类对象，可以根据实际对象的类型来调用相应的方法



多态性可以通过继承和方法重写来实现。

多态的实现方式：

运行时多态实现的关键是继承和方法重写。子类可以重写父类的方法，通过使用父类引用指向子类对象，可以根据实际对象的类型来调用相应的方法。这样可以实现面向对象编程中的一个重要原则："编写代码时，应该针对接口编程，而不是针对实现编程"。

1. 编译时多态（静态多态）：通过方法重载（Method Overloading）实现。在编译时，根据方法的参数类型和数量来确定调用哪个方法。编译器会根据调用时传递的参数类型来选择合适的方法进行调用。
2. 运行时多态（动态多态）：通过方法重写（Method Overriding）和继承实现。在运行时，根据对象的实际类型来确定调用哪个方法。父类引用可以指向子类对象，通过父类引用调用被子类重写的方法时，实际执行的是子类的方法。



## `Redis`缓存机制

1. 数据存储：`Redis`将数据存储在内存中，以键值对的形式进行存储。这种存储方式使得`Redis`能够快速读取和写入数据，提供低延迟的缓存访问。
2. 缓存淘汰策略：`Redis`支持多种缓存淘汰策略，用于在内存不足时决定哪些数据应该被淘汰。常见的淘汰策略包括`LRU`（最近最少使用）、`LFU`（最不经常使用）和随机等。这些策略可以根据业务需求进行配置，以提高缓存命中率和数据访问效率。
3. 缓存失效机制：`Redis`支持设置键的过期时间，当键过期时，`Redis`会自动将其从缓存中删除。这种机制可以用于处理缓存数据的时效性，确保缓存中的数据不会过期而导致数据不一致的问题。
4. 缓存更新策略：在数据更新时   ，`Redis`提供了多种更新策略。常见的方式是通过发布订阅机制或使用触发器来实现数据更新的同时更新缓存。这样可以保证缓存中的数据与后端存储中的数据保持一致。
5. 分布式缓存：`Redis`支持分布式部署，可以通过主从复制或集群模式实现数据的分布式缓存。这样可以提高系统的容量和可扩展性，同时提供高可用性的缓存服务。

### `Redis`五大基本数据类型

字符串（String）、列表（List）、哈希（Hash）、集合（set）、有序集合（Sorted Set）(收得赛特)

## 抽象类必须要有抽象方法吗？

不需要，抽象类不一定必须要抽象方法，但抽象方法必须是抽象类。

## 集合和数组的区别

数组可以储存同一种数据类型，而集合可以储存不同的数据类型。数组的长度是固定的一旦创建后无法改变。而集合的大小是可变的，可以根据需要动态添加或删除元素。

1. 功能和操作：数组是一个简单的数据结构，提供了基本的访问和操作方法，如根据索引访问元素、修改元素值等。集合是一个更高级的数据结构，提供了丰富的功能和操作方法，如添加、删除、遍历、查找、排序等。
2. 内存管理：数组在内存中是连续存储的，分配一块固定大小的内存空间。集合在内存中可以是不连续的，它们通常使用动态内存分配来管理元素。

## `final`有什么用？

final可以修饰类、方法和变量。

被final修饰过的类不能被继承、被修饰的方法不能被重写、被final修饰的变量不能被改变。

`final` 关键字的使用可以提供代码的安全性和稳定性。final可以保护程序逻辑的完整性

## finally 

`finally `一般作用与try-catch代码块中，表示改代码无论是否发生异常都会继续执行下去。一般用于释放资源等。

## finalize

`finalize`是`java`中的一个方法，当对象不在被引用或者被垃圾回收器收回对象时`finalize`会自动调用

## String 类的常用方法都有那些？

1. `indexOf()`：返回指定字符的索引。
2. `charAt()`：返回指定索引处的字符。
3. `replace()`(瑞普类)：字符串替换。
4. `trim()`(存母)：去除字符串两端空白。
5. `split()`（死不类吃）：分割字符串，返回一个分割后的字符串数组。
6. `getBytes()`：返回字符串的 byte 类型数组。
7. `length()`：返回字符串长度。
8. `toLowerCase()`(图楼我k死)：将字符串转成小写字母。
9. `toUpperCase()`（图啊普k死）：将字符串转成大写字符。
10. `substring()`：截取字符串。
11. `equals()`：字符串比较。

## `ArrayList`、`LinkedList`、`Vector` 的区别？

底层实现：

`ArrayList`（哦list） 和 `Vector `都是基于数组实现的动态数组，它们通过动态数组来存储元素。但`Vector `在操作上是同步的（也就是他的线程是安全的）

`LinkedList`是使用双向链表来存储元素,每个元素都包含对前一个和后一个元素的引用。

性能问题：

- `ArrayList` 的随机访问（根据索引获取元素）性能较好，因为它可以通过索引直接访问数组中的元素。遍历操作也比较高效。

- `LinkedList` 的随机访问性能较差，因为需要从头或尾开始遍历链表，直到找到目标元素。但在插入和删除操作上，`LinkedList `的性能较好，因为只需要调整链表中的指针即可。

- `Vector` 的随机访问性能与` ArrayList `类似，也可以通过索引直接访问数组中的元素。但是因为他的操作是同步的所以在更新和插入时他的速度比`ArrayList`性能较低。

- `ArrayList` 和 `Vector` 的大小可以根据需要动态调整，但扩容时需要进行数组的复制和调整大小操作，可能会带来一些性能开销。
- `LinkedList` 的大小没有限制，可以根据需要动态添加和删除元素。

如果不需要线程安全性且需要高效的随机访问操作，可以使用 `ArrayList`。如果需要频繁的插入和删除操作，可以选择 `LinkedList`。如果需要线程安全性，可以使用 Vector。

## `Synchronized`用过吗，其原理是什么?

`Synchronized`(心普奈死)是Java中的关键字，用于实现线程同步和互斥访问。它可以应用于方法或代码块，以确保在同一时间只有一个线程可以访问被同步的代码，从而避免多个线程同时对共享资源进行修改而导致的数据不一致或并发问题。

1. 被 Synchronized 修饰过的程序块编译后的字节码，会发现被 Synchronized 修饰过的程序块，在编译前后被编译器生成了 `monitorenter`(莫来特爱特) 和` monitorexit`（莫来特爱神） 两个字节码指令。
2. 这两个指令是什么意思呢？当虚拟机执行到` monitorenter` 指令时，首先要尝试获取对象的锁：如果这个对象没有被其他线程锁定，或者当前线程已经拥有了这个对象的锁，那么就将锁的计数器加 1。当执行` monitorexit` 指令时，需要释放对象的锁，将锁计数器减 1。
3. 如果获取对象的锁失败，当前线程就会被阻塞等待，直到对象的锁被另外一个线程释放为止。在 Java 中，使用 Synchronized 关键字来实现同步操作，它通过在对象头部设置标记来达到获取锁和释放锁的目的。

原理：

`Synchronized`关键字的原理涉及到Java中的对象监视器（也称为内置锁或监视器锁）和线程的状态转换。

当线程进入到一个被`Synchronized`关键字修饰的方法和代码块中，它会尝试获取锁对象的锁，如果没有被其他线程占用则会将该线程获得锁同时执行代码，如果锁已经被占用了那么当前线程会被阻塞，进入等待状态。当一个线程持有锁并执行完同步代码后，它会释放锁。释放锁意味着该线程不再持有对象监视器的锁，锁进入非锁定状态，其他线程有机会获取该锁。如果有其他线程在等待获取锁，一旦锁被释放，等待的线程中的一个将获得锁，并进入锁定状态。获得锁的线程可以继续执行同步代码，而其他线程仍然需要等待锁的释放才能获取锁并执行同步代码。

## 重写和重载

- 重写（`Override`）：子类中重新实现（覆盖）父类中已有的方法，具有相同的名称、参数列表和返回类型。

- 重载（`Overload`）：在同一个类中定义多个具有相同名称但参数列表不同的方法，通过参数类型、参数个数或参数顺序的不同来区分。

  

## `java`集合框架

Java集合框架：

Java集合框架是Java提供的一组接口和类，用于存储和操作一组对象。它提供了各种类型的集合类，包括列表（`List`）、集合（`Set`）、映射（`Map`）等。常用的集合类包括：

1. `ArrayList`：动态数组，实现了List接口。
2. `LinkedList`：链表，实现了List接口。
3. `HashSet`：无序的集合，不允许重复元素，实现了`Set`接口。
4. `TreeSet`(崔赛特)：有序的集合，不允许重复元素，实现了`SortedSet`接口。
5. `HashMap`：无序的键值对集合，不允许重复键，实现了Map接口。
6. `TreeMap`：有序的键值对集合，不允许重复键，实现了`SortedMap`接口。

## 在Java中，可以通过两种方式创建和启动线程：

1. 继承Thread类：创建一个继承自Thread类的子类，重写run()方法，然后创建该子类的实例，并调用start()方法启动线程。

2. 实现Runnable接口：创建一个实现了Runnable接口的类，实现run()方法，然后创建该类的实例，并将其作为参数传递给Thread类的构造方法，最后调用start()方法启动线程。

   ## 乐观锁和悲观锁

- 悲观锁假设会发生并发冲突，在访问资源之前先获取锁，而乐观锁假设并发冲突的概率较低，在更新操作时检查是否发生冲突。
- 悲观锁在获取锁后其他事务必须等待，而乐观锁在发生冲突时需要处理冲突的情况。
- 悲观锁适用于对数据一致性要求较高的场景，乐观锁适用于并发冲突概率较低的场景。
