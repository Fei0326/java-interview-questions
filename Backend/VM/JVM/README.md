JVM 面试专题
========

## 内存模型以及分区，需要详细到每个区放什么？

JVM 分为堆区(Heap)和栈区(Stack)，还有方法区(Method Area)，初始化的对象放在堆里面，引用放在栈里面，class 类信息常量池（static 常量和 static 变量）等放在方法区 。方法区主要是存储类信息，常量池（static 常量和 static 变量），编译后的代码（字节码）等数据。

1.  堆：初始化的对象，成员变量 （那种非 static 的变量），所有的对象实例和数组都要在堆上分配。
2.  栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操作数栈，方法出口等信息，局部变量表存放的是 8 大基础类型加上一个应用类 型，所以还是一个指向地址的指针。
3.  本地方法栈：主要为 Native 方服务。
4.  程序计数器：记录当前线程执行的行号。

## 堆里面的分区：Eden，Survival （from+ to），老年代，各自的特点。

1.  堆里面分为新生代和老生代（Java8 取消了永久代，采用了 Metaspace），新生代包含 Eden+Survivor 区，Survivor 区里面分为 from 和 to 区， 内存回收时，如果用的是复制算法，从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动到老年区，当 JVM 内存不够用的时候，会触发 Full GC，清理 JVM 老年区当新生区满了之后会触发 YGC, 先把存活的对象放到其中一个 Survice 区，然后进行垃圾清理。
2.  因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候，就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存活时间一般比较久远。

## GC 的两种判定方法：

1.  引用计数法：指的是如果某个地方引用了这个对象就 + 1，如果失效了就 - 1，当为 0 就会回收但是 JVM 没有用这种方式，因为无法判定相互循环引用（A 引用 B,B 引用 A）的情况。
2.  引用链法： 通过一种 GC ROOT 的对象（方法区中静态变量引用的对象等 - static 变量）来判断，如果有一条链能够到达 GC ROOT 就说明，不能到达 GC ROOT 就说明可以回收。

## GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？

先标记，标记完毕之后再清除，效率不高，会产生碎片复制算法：分为 8：1 的 Eden 区和 Survivor 区，就是上面谈到的 YGC 标记整理：标记完毕之后，让所有存活的对象向一端移动。

## GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。

1.  并行收集器：串行收集器使用单个线程进行垃圾收集，会在 GC 时停止服务。而并行收集器使用多个线程同时进行垃圾收集，可以更快地完成垃圾回收。
2.  并发收集器：在 GC 时服务不会停止，使用多线程来执行垃圾回收，因此不会出现长时间停顿的情况。CMS 收集器就是一种并发收集器，它是基于 “标记 — 清除” 算法实现的，会经过多次标记才会进行垃圾回收。
3.  CMS 收集器的特点：是一种并发收集器，能够在 GC 时服务不停顿，但因为采用标记清除算法，容易出现碎片化问题，可能导致频繁进行 Full GC，从而影响系统的性能。
4.  G1 收集器的特点：从整体上看是基于 “标记 — 整理” 算法实现的收集器，会对堆内存进行划分，然后使用多个线程并发执行垃圾回收。从局部（两个 Region 之间）上看是基于 “复制” 算法实现的，可以避免碎片化问题，因此能够更好地保证系统的性能。同时，G1 收集器还能够根据垃圾分布情况来优化垃圾回收过程，进一步提高系统的性能。

## Minor GC 与 Full GC 分别在什么时候发生？

新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC。

## 简述 Java 垃圾回收机制？

在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合 中，进行回收。

## Java 中垃圾收集的方法有哪些？

1.  标记 - 清除：这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.1. 效率不高，标记和清除的效率都很低；1.2. 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。
2.  复制算法：为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。于是将该算法进行了改进，内存区域不再是按照 1：1 去划分，而是将内存划分为 8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。(Java 堆又分为新生代和老年代)。
3.  标记 - 整理：该算法主要是为了解决标记 - 清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。
4.  分代收集：现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记 - 整理 或者 标记 - 清除。

## 简述 Java 类加载机制？

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。

## 什么是类加载器，类加载器有哪些？

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。主要有一下四种类加载器:

1.  启动类加载器 (Bootstrap ClassLoader) 用来加载 java 核心类库，无法被 java 程序直接引用。
2.  扩展类加载器 (extensions class loader): 它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3.  系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader () 来获取它。
4.  用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。

## 说一下 JVM 调优的工具？

DK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。jconsole：用于对 JVM 中的内存、线程和类等进行监控；jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。

## 常用的 JVM 调优的参数都有哪些？

1.  `-Xms2g`：初始化推大小为 2g；
2.  `-Xmx2g`：堆最大内存为 2g；
3.  `-XX:NewRatio=4`：设置年轻的和老年代的内存比例为 1:4；
4.  `-XX:SurvivorRatio=8`：设置新生代 Eden 和 Survivor 比例为 8:2；
5.  `–XX:+UseParNewGC`：指定使用 ParNew + Serial Old 垃圾回收器组合；
6.  `-XX:+UseParallelOldGC`：指定使用 ParNew + ParNew Old 垃圾回收器组合；
7.  `-XX:+UseConcMarkSweepGC`：指定使用 CMS + Serial Old 垃圾回收器组合；
8.  `-XX:+PrintGC`：开启打印 gc 信息；
9.  `-XX:+PrintGCDetails`：打印 gc 详细